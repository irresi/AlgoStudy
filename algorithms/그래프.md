# 그래프

## 위상정렬

priority_queue에 {진입차수,idx}를 저장해 구현하는 방식과 dfs를 종료하는 순으로 저장하는 방식이 있다.
dfs를 이용하는 구현이 좀 더 빠르다.

0번 상태 : 노드가 아직 처리되지 않았다.
1번 상태 : 노드가 처리되는 중이다.
2번 상태 : 노드의 처리가 끝났다.

```C++
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;
const int inf=1e9+3;
#define all(x) (x).begin(),(x).end()
#define sync() {ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);} //do not use 
int n,m;
int state[32003];
vector<int> ed[32003];
vector<int> ans;
bool hascycle=false;
void dfs(int cur){
	state[cur]=1;
	for(int nxt : ed[cur]){
		if(!state[nxt]) dfs(nxt);
		else if(state[nxt]==1) hascycle=true;
	}
	state[cur]=2;
	ans.push_back(cur);
}
int main()
{
	int i,a,b;
	sync()
    cin>>n>>m;
    for(i=1;i<=m;i++){
    	cin>>a>>b;
    	ed[a].push_back(b);
    }
    for(i=1;i<=n;i++){
    	if(!state[i]) dfs(i);
    }
    reverse(all(ans));
    for(int num : ans) cout<<num<<' ';
    return 0;
}

```



## SCC

Strongly Connected Component는 모든 노드에서 다른 모든 노드로 가는 경로가 있는 최대노드 집합이다.

### 코사라주

1. 깊이 우선 탐색이 처리하는 순서대로 노드리스트 만들기
2. 노드리스트의 반대 순서대로 노드 살펴보기
   - 노드가 컴포넌트에 속하지 않았다면
     역방향 그래프를 돌며 해당 컴포넌트에 방문한 노드 추가

역방향그래프를 미리 만들어 놓고 노드리스트의 반대 순서대로 노드를 살펴보는 것을 스택을 이용했다.

```C++
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;
const int inf=1e9+3;
#define all(x) (x).begin(),(x).end()
#define sync() {ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);} 
int n,m,cnt;
vector<int> ed[10003],red[10003],chk(10003);
vector<vector<int>> ans(10003);
stack<int> st;
void dfs(int num){
	chk[num]=1;
	for(int nxt : ed[num])if(!chk[nxt]){
		dfs(nxt);
	}
	st.push(num);
}
void rdfs(int num){
	chk[num]=0;
	ans[cnt].push_back(num);
	for(int nxt : red[num])if(chk[nxt]){
		rdfs(nxt);
	}
}
int main()
{
	int i,j,a,b;
    cin>>n>>m;
    for(i=1;i<=m;i++){
    	cin>>a>>b;
    	ed[a].push_back(b);
    	red[b].push_back(a);
    }
    for(i=1;i<=n;i++)if(!chk[i]){
    	dfs(i);
    }
    while(!st.empty()){
    	if(chk[st.top()]){
    		++cnt; rdfs(st.top());
    	}
    	st.pop();
    }
    cout<<cnt<<'\n';
    for(i=1;i<=cnt;i++)	sort(all(ans[i]));
    sort(ans.begin()+1,ans.begin()+1+cnt);
    for(i=1;i<=cnt;i++){
    	for(int num : ans[i]) cout<<num<<' ';
    	cout<<"-1\n";
    }
    return 0;
}

```

## 오일러 회로

http://www.secmem.org/blog/2021/04/14/Euler-Circuit-and-Path/

### Hierholzer's Algorithm O(E)

```c++
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;
const int inf=1e9+3;
#define all(x) (x).begin(),(x).end()
#define sync() {ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);} //do not use
int n;
vector<pair<int, int>> g[1003];
int pos[1003];
void dfs(int v){
	while(pos[v]<g[v].size()){
		auto [w,ind] = g[v][pos[v]];
		if(w==-1) {
			pos[v]++; continue;
		}
		g[v][pos[v]].first=-1; g[w][ind].first=-1;
        pos[v]++;
		dfs(w);
	}
    cout<<v<<' ';
	return;
}
int main()
{
	int i,j,num,sum,flag=0;
    cin>>n;
    for(i=1;i<=n;i++){
        sum=0;
    	for(j=1;j<=n;j++){
    		cin>>num;
    		sum+=num;
    		if(i<j){
                while(num--){
                    g[i].emplace_back(j,g[j].size());
                    g[j].emplace_back(i,g[i].size()-1);
                }
    		}
    	}
        if(sum&1) flag=1;
    }
    if(flag) cout<<"-1";
    else dfs(1);
    return 0;
}

```

