# 최단거리

## 최소비용신장트리 MST

모든 정점을 잇는 사이클이 없는 경로의 최소비용을 구하는 문제

### Kruscal O(E lg E)

가중치가 작은 간선을 하나씩 선택하여 사이클이 생기지 않도록 잇는다.

#### 기본 코드

```c++
#include <bits/stdc++.h>
using namespace std;
int v, e,g[100003];
struct data{
    int a,b,val;
    bool operator<(const data &r)const{
        return val<r.val;
    }
}arr[100003];
long long ans;
int fnd(int num){
    return num==g[num]?num:g[num]=fnd(g[num]);
}
int uni(int a, int b){
    g[b=fnd(b)]=(a=fnd(a));
    return a!=b;
}
int main()
{
    int i;
    scanf("%d %d",&v,&e);
    for(i=1;i<=e;i++){
        scanf("%d %d %d",&arr[i].a,&arr[i].b,&arr[i].val);
    }
    for(i=1;i<=v;i++) g[i]=i;
    sort(arr+1,arr+1+e);
    for(i=1;i<=e;i++){
        ans+=uni(arr[i].a,arr[i].b)*arr[i].val;
    }
    printf("%d",ans);
    return 0;
}

```

#### 구조체화

```c++
//kruscal
#include <bits/stdc++.h>
using namespace std;
using ll = long long int;
#define all(x) (x).begin(),(x).end()
#define sync() {ios_base::sync_with_stdio(0); cin.tie(0);cout.tie(0);} //do not use
int v,e,ans=0;
struct UnionFind{
	vector<int> G;
	UnionFind(int n){G.resize(n); iota(all(G),0);}
	int fnd(int num){return num==G[num]?num:G[num]=fnd(G[num]);}
	bool merge(int a, int b){
		G[fnd(a)]=G[fnd(b)];
		return a!=b;
	}
};
struct MST{
	vector<vector<ll>> ed; //cost, u, v
	vector<vector<ll>*> getp(){
		sort(all(ed));
		vector<vector<ll>*> p;
		UnionFind UF(v+1);
		for(auto& t : ed){
			if(UF.merge(t[1],t[2])) p.push_back(&t);
		}
		return p;
	}
	ll getcost(){
	    ll ans=0;
        auto path = getp();
        for(auto t : path) ans+=(*t)[0];
        return ans;
	}
};
```

### Prim O(E lg E)

현재 정점과 연결된 간선들 중 가장 가중치가 작은 간선을 추가한다.

#### 코드

```

```



## 최단거리

### Floyd-Warshall O(N^3)

가장 기본적이고 간단한 알고리즘. 모든 쌍의 노드들에 대한 최단 거리를 구한다. 



### Dijkstra O(N lg N)

한 노드에서 다른 노드들까지의 최단 거리를 구한다. 우선순위 큐를 이용해 현재정점과 연결된 가장 가중치가 작은 노드를 선택하고 연결된 다른 노드들의 거리를 갱신한다.



Bellman-Ford