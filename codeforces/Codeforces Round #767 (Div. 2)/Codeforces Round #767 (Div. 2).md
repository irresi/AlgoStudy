
 

# [Codeforces Round #767 (Div. 2)](https://codeforces.com/contest/1629)

## C. Meximum Array

1. 남은 array에서 MEX를 찾는다.
2. 남은 array에서 앞에서부터 하나씩 pop하면서 체크할 때 MEX미만의 모든 수가 등장하면 1로 이동한다.

이 때 MEX를 찾는 것을 모든 array를 iterate하면서 찾지 않고 모든 수의 개수를 세 놓았다가 2의 과정을 할 때 등장한 수의 개수를 하나씩 차감한다. 이 때 수의 개수가 0이 된 수 중 가장 작은 수를 MEX로 놓는다.

---

세그먼트 트리를 사용해야 될 것 같다는 자료구조에 의해 생각이 제한되어 쉬운 풀이를 놓쳤다.
자료구조와 알고리즘은 그저 도구와 매뉴얼 같은 것이니 그 것에 너무 얽매이지 말자.

## D. Peculiar Movie Preferences

- 길이가 1인 문자열는 무조건 팰린드롬이다.
- 길이가 2인 문자열은 길이가 2 혹은 3인 문자열과 결합할 수 있다.
- 길이가 3인 문자열은 길이가 2 혹은 3인 문자열과 결합할 수 있다.

이 때 길이가 같은 문자열은 서로 reverse한 결과가 다른 문자열과 같으면 서로 합쳐졌을 때 palindrome이다.

길이가 다른 문자열은 길이가 긴 1 더 긴 문자열을 reverse한 것에서 마지막 문자를 제거한 것과 다른 길이가 짧은 문자열이 같아야 한다.

---

3개 이상의 문자열이 결합되어 만들어진 palindrome은 항상 그 중 2개를 선택해도 palindrome을 만들 수 있다.
그래서 문자열을 2개 결합하는 경우만 보면 되고 나는 이 것을 multiset을 이용하여 구현했는데 자꾸 틀렸다.
Multiset에서 확인한 문자열을 하나씩 순서대로 지워나갔고 논리적 구조가 아무리 봐도 완벽했는데 계속 틀려서 1시간 넘게 맞왜틀! 하고 있었다. 

for문을 돌면서 문자열을 하나씩 Multiset에서 erase하고 있던게 문제였다. Multiset에서 string을 erase하면 모든 string이 지워진다. 하나만 지우려면 iterator를 이용해야 해서

Multiset<string> lib;
string s;
lib.erase(s)와 같이 하면 안 되고 lib.erase(lib.find(s))와 같이 iterator를 넣어서 하나씩 지워야했다.
상위권에 있는 사람들은 어차피 문자열이 3자리이니 26진수처럼 생각해서 해시함수로 구현했다. 
아마 Multiset을 안  쓰고 Map으로 구현했으면 맞왜틀! 안 했을 것 같은데 여러모로 좀 아쉬웠다.