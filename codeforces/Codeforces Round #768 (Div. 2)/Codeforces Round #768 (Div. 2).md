# [Codeforces Round #768 (Div. 2)](https://codeforces.com/contest/1631)

## A. Min Max Swap

a[i]=min(a[i],b[i]), b[i]=max(a[i],b[i])로 놓으면 max($a_1,\cdots,a_n$)*max($b_1,\cdots,b_n$)이 최소가 된다.

어차피 2*n개의 수 중 가장 큰 수는 a 혹은 b의 최댓값이다. 최댓값이 포함되지 않은 배열의 최댓값을 최소화하면 두 배열의 최댓값의 곱이 최소가 된다.

3min

## B. Fun with Even Subarrays

그리디하게 생각하면 된다. t개의 뒤에 있는 수를 앞에 복사하는 것이다. 가장 뒤에 있는 수는 바뀌지 않기 때문에 배열의 모든 수를 가장 뒤에 있는 수와 같게 만들어야 한다. a[n-t+1]~a[n]개의 t개의 수가 모두 같도록 하는 t를 항상 최대화하고 그 것들을 앞으로 복사한다. 이렇게 반복하다가 모든 원소가 같아지면 그 때까지 반복한 연산 횟수를 출력한다.
11min

## C. And Matching

모든 쌍을 &한 것의 합이 0이 되도록 구성하려면 {0,n-1}, {1,n-2}, ... {i,n-1-i}... {n/2-2,n/2+1},{n/2-1,n/2}과 같이 구성하면 된다.
x&0=0, x&(n-1)=x이기 때문에(n-1은 $2^p-1꼴$) 모든 쌍을 &한 것의 합이 k가 되도록 구성하려면 0이 되도록 구성한 쌍들에서 0과 k의 위치를 바꾸면 된다.

단, k=n-1일 때는 0과 n-1이 같은 쌍에 있기 때문에 swap하더라도 원래 쌍에서 바뀌는 것이 없다.
그래서 &의 합이 0이 되는 쌍들에서 2개의 쌍을 변경하는 것이 아니라 3개의 쌍을 변경해야 한다.

 {0,n-1}, {n/2-2,n/2+1}, {n/2-1,n/2} 쌍을 {n-1,n/2-1},{n/2,n/2+1},{0,n/2-2}와 같이 변경하면 가장 앞 쌍의 &한 결과가 n/2-1 두 번째 쌍의 &한 결과가 n/2 세 번째 쌍의 &한 결과가 0이고 나머지 쌍들의 &한 결과 역시 0이기 때문에 합이 n-1이 된다.

41min, -1
k=n-1일 때를 고려하지 않아 1번 틀리고 15분을 더 썼다.

## D. Range and Participation

78min

## E. Paint the Middle

그리디하게 풀었는데 틀림.