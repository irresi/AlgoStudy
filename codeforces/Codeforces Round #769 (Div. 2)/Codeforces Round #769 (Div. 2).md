### C. Strange Test

#### 풀이

a<b인 두수 a,b가 있을 때  a++, b++,a|=b 3가지 연산만을 사용하여 a=b로 만드는 최소연산횟수를 구하시오.

##### 1. a|=b를 1번만 사용하는 것이 최적이다.

연산 후에는 항상 a가 b이상이 된다. 이 연산 후에는 그냥 b를 a까지 증가시키는 연산만 하면 된다. 다시 a|=b를 하면 a를 더 증가시키게 되고 이건 연산 횟수를 늘린다. 그래서 1번만 사용하는 것이 최적이다.

##### 2. 식의 변형

a|=b를 1번만 사용하는 것이 최적이니 $a \leq a', b \leq b'$ 이라고 할 때 
답은 $(a'-a)+(b'-b)+(a'|b'-b')+1=a'+a'|b' + (1-a-b)$이다. 
즉 상수인 a와 b를 제외하고 $a' + a'|b'$을 최소로 만들면 된다. 

##### 3. 최소 횟수 찾기

$a'\leq b$​이니 a'을 a부터 b까지 iterate하면서 $a'|b'$​의 최솟값을 찾으면 된다.
a'과 b의 상위비트부터 하위비트까지 내려가면서 b'을 만든다.

![image-20220202115757278](C:\Users\skybl\AppData\Roaming\Typora\typora-user-images\image-20220202115757278.png)

현재 가장 상위비트가 a'과 b가 모두 0이거나 1인 경우 b'이 각각 0, 1이 되어야 하는 것은 자명하다.

현재비트에서 a'=1이고 b=0인 경우 a'|b'은 1이 된다. b'을 1로 두고 뒤비트들을 모두 0으로 두면 a'|b'이 현재비트이하의 값에서 최소가 된다.

현재비트에서 a'=0이고 b=1인 경우 b'을 0으로 set하게 되면 b'의 상위비트가 1이 되어야 한다. 그리고 a|b'이 더 커지게 된다. 그래서 b'은 0으로 둬야 한다. 그리고 가정자체가 현재의 상위비트만을 바꾸어야 하고 현재비트의 상위비트들은 모두 최적으로 처리가 된 것이니 현재비트의 상위비트를 바꾸는 연산은 할 수 없다.

### D. New Year Contest

#### 풀이

1. 만약 $gcd(a_l, \cdots, a_r) = r-l+1$이라면.어떤 구간 [l,r]을 "bad"라고 정의하자. 그럼 최대 n개의  bad 세그먼트들이 있다.
2. 고정된 l에 대해 r이 커지면 $gcd(a_l,\cdots,a_r)$은 증가하지 않는다.
3. $a_i$를 매우 큰 소수로 바꾸면 $gcd(a_j,a_i)(j<i)$는 항상 1이다.

모든 bad구간을 찾아보자. 고정된 l에 대해 $gcd(a_l,\cdots,a_r) \geq r-l+1$인 가장 큰 r을 찾자. 이 것은 이진탐색과 sparse table / segment tree를 통해 해결할 수 있다. 만약 $gcd(a_l,\cdots,a_r) = r-l+1$이면 [l,r]은 bad 구간이다.

만약 $a_i$를 매우 큰 소수로 바꾸면 새로운 bad 구간이 생기지 않는다. 그리고 i를 포함하고 있는 모든 bad 구간들이 사라진다. 그래서 우리는 이 구간들을 모두 없앨 최소 숫자를 찾아야 한다. 이거는 전형적인 그리디 문제로 r을 정렬하는 방법으로 풀 수 있다.

#### 보강할 점

위에 언급된 3가지 성질은 모두 생각했는데 그냥 더 생각하지 않고 naive하게 풀려고 했다. 

커질수록 gcd는 r이 감소하고 r-l+1인 증가한다. 이 성질을 이용해 이진탐색을 할 수 있다는 걸 생각했어야 되었다.

sparse table에 대해서는 잠깐 생각했었으니 아마 그러면 풀었을 것 같다.