# Codeforces Round #770 (Div. 2)

## A. Reverse and Concatenate

### 풀이

어떤 문자열 s를 한 번 연산한 결과는 s + rev(s), rev(s)+s 이다. 이 두 문자열에 다시 연산을 적용하면 s+rev(s)+s+rev(s), rev(s)+s+rev(s)+s가 된다. 연산을 두 번 적용한 결과들이 모두 팰린드롬이기 때문에 rev(s)==s이고 s+s라는 문자열 덧셈 연산을 이후에는 수행하게 된다.
따라서 rev(s)==s이거나 k==0(문자열 연산 0번)일 경우 답은 1, 나머지의 경우 답은 2가 된다.

3 min

## B. Fortune Telling

엘리스는 x에서 시작하고 밥은 x+3에서 시작한다. 그리고 같은 수($a_i$)를 더하거나 xor하여 어떤 한 친구가 y를 만들었다. y를 만든 사람은 누구일까?

### 풀이 

가장 하위비트에서 덧셈과 xor모두
0+0=0, 0^0=0
0+1=1, 0^1=1
1+0=1, 1^0=1
1+1=0, 1^1=0
요렇게 1이 짝수 개이면 0, 1이 홀수 개이면 1이 된다. 즉, 어떤 수에 $a_i$를 모두 더한 것의 홀짝성이 y의 홀짝성과 같아야 한다. 따라서 y+$\sum{a_i}$의 홀짝성와 x의 홀짝성, x+3의 홀짝성을 비교하여 홀짝성이 같은 사람을 답으로 출력하면 된다.

21min
대회 때는 홀짝성이 아니라  y에서 $a_i$를 빼거나 xor한 것의 4로 나눈 나머지를 저장하는 식으로 풀었다. 이제 다시 보니 2로 나눈 나머지만 고려하고 $a_i$를 더하기만 하면 되었었다.

## C. OKEA

n행 k열 배열에 1부터 n*k까지의 수를 배치한다. 이 때 임의의 행에서 연속된 열의 숫자를 선택했을 때 그 수의 평균이 정수가 되도록 수를 배치해야 한다. n과 k가 주어질 때 이러한 배치 중 1가지를 출력하시오.

### 풀이

일단 임의의 n행짜리 배열에서 한 행만 고려해보자. 
가장 앞의 원소가 a라고 하고 그 뒤의 원소가 a+2d라고 해 보자.(a, d는 임의의 정수, 1<=모든 원소<=n*k)
그 다음 원소를 x라 했을 때 a+2d+x=0(mod 2), 2a+2d+x=0(mod 3) 
x=a(mod 2), x=a+d(mod 3)이니 x=a+4d로 놓으면 두 모듈러 조건을 모두 만족시킨다.
a+2d, a+4d에 대해서도 위와 같은 생각을 해보면 다음 항이 x=a+6d가 될 수 있다는 것을 알 수 있다.
따라서 등차가 짝수인 등차수열을 생각할 수 있다. 
등차수열의 연속된 부분을 선택한 수열도 등차수열이고 
등차수열의 평균은 항상 (첫 항+마지막 항)/2로 나타낼 수 있기 때문에 등차가 짝수인 등차수열은 배치 조건을 만족한다. 또한 배치 조건을 만족하는 것이 등차가 짝수인 등차수열이라는 역도 성립한다. 증명은 이 명제를 대우해서 홀짝성을 이용하여 할 수 있다. 어떤 행이 배치 조건을 만족한다 <=> 어떤 행이 등차가 짝수인 등차수열이다.

행이 홀수일 경우 열이 1인 경우를 제외하고는 배치조건을 만족할 수 없다. 등차가 짝수인 것은 해당 행의 홀짝성이 같다는 것인데 행이 홀수인 경우 홀수의 개수와 짝수의 개수가 맞지 않다.

행이 짝수인 경우 등차를 2로 고정시켜 2줄씩 만들어 나가거나 
등차를 n으로 고정시키고 i행 1열의 수를 i로 놓으면 등차가 짝수인 등차수열이니 위 배치 조건을 만족하게 된다.

32min
대회 때는 직관적으로 1부터 n*k의 수를 열 우선, 행 차선으로 순서대로 배치하면 될 것 같다는 생각이 들었다. 몇 가지 예시를 생각해보다가 등차수열에 대해 생각하게 되었고 이렇게 배치하면 답이 된다는 것을 알았다.

## D. Finding Zero

음이 아닌 정수 배열 $a_1,a_2,\cdots,a_n$의 배열에 0이 하나 있다.
? i j k라는 쿼리를 보내면 $max(a_i,a_j,a_k)-min(a_i,a_j,a_k)$를 반환한다. 이 때 2n-2번 이하의 쿼리를 수행하여 0으로 추측하는 인덱스 2개를 출력해라. 이 인덱스에 해당하는 값 중 하나가 0이면 정답

### 풀이

0이 될 수 없는 것을 주어진 연산을 통해 후보에서 배제해야 한다.
원소가 3개인 경우를 생각해 보면 쿼리에 이 원소들을 넣어도 어떤 원소가 0인지, 어떤 원소가 0이 될수없는지 알 수 없다.

원소가 4개(a,b,c,d)인 경우를 생각해 보자.
4개의 원소 중 a가 가장 크고 d가 가장 작다면

? a b c = a-b or a-c
? a b d = a-d
? a c d = a-d
? b c d = b-c or b-d
와 같은 결과가 나온다.
a가 가장 크고 d가 가장 작으니 쿼리의 결과값중 a-d가 가장 크다.
즉, 4개의 원소 중 3개의 원소를 골라 쿼리를 돌린다. 이 때 결과값이 가장 큰 쿼리에 가장 큰 원소와 가장 작은 원소가 포함되어 있다. 그리고 이 결과값이 가장 큰 쿼리에 포함되지 않은 한 원소는 0이 될 수 없기 때문에 후보에서 배제할 수 있다. a b d = a-d를 보면 c가 포함되어 있지 않다. a혹은 b혹은 d가 가장 큰 원소인데 c가 0일 경우 0은 유일하므로 c와 가장 큰 원소가 포함된 쿼리의 결과값이 더 크게 나와야 한다. 이는 쿼리의 결과값 중 a b d가 가장 크다는 것에 모순이므로 c는 0이 될 수 없다. 
이런식으로 4개의 쿼리를 통해 0이 될 수 없는 수를 배제할 수 있다.
n이 짝수인 경우 계속 2개씩 수를 배제하면 (n-2)/2*4 = 2(n-2)번 만에 0이 될 수 있는 후보 2개를 고를 수 있답.
n이 홀수인 경우 마지막에 수가 3개 남는데 0이 될 수 없는 수로 판별된 수 중 하나를 추가하여 원소를 4개로 만든 후 연산을 할 수 있다. 따라서 원소가 n+1개인 짝수의 경우와 연산 횟수가 같고 2(n-1)번 만에 후보 2개를 고를 수 있다.

95min
처음에는 max(a,b)=(|a-b|+a+b)/2로 나타낼 수 있다는 것을 이용하여 max가 3개의 원소로 이루어졌을 때 min이 3개의 원소로 이루어졌을 때의 수식을 변형하면서 구하려고 했다. 그리고 어떤 수가 0이 될 수 있는지에 초점을 맞추어 생각했다. 이런 주어진 쿼라 안에 수를 맞추어야 하는 문제, 특히 수가 될 수 있는 후보를 여러 개 출력하는 문제는 후보가 될 수 없는 수를 배제하는 쪽으로 생각하는 것이 좋은 것 같다.

## E. Fair Share

원소가 $2n_i$개인 m행의 배열이 주어진다. 이 때 행별로 $n_i$개의 원소를 멀티셋 L과 R에 넣어서 L과 R을 같게 만들어야 한다. 불가능하면 NO를 출력하고 가능하다면 YES를 출력하고 각 원소들이 L과 R중 어느 곳에 속하는 지 출력한다.

대회 때 1시간 고민했는데 못 풀었다.

Hint1
답이 명확히 NO인 경우는 어떤 경우가 있는가?

Hint2
모든 배열의 길이는 짝수이고, 모든 수는 총 짝수 번 등장한다. 의심스럽게도 많은 짝수 숫자들이 존재한다.

Hint 3
오일러 회로는 그래프의 모든 간선을 한 번씩 통과하는 회로이다.(혹은 그래프가 연결되어 있지 않다면 몇 개의 회로의 집합)  각각의 정점의 차수가 짝수일때만 오일러 서킷은 존재한다.

Hint4
모든 정점의 차수가 짝수개 일 때 어떤 그래프를 구성해 보고 방향이 있는 오일러 회로를 찾아 보고, 그 회로를 이용해서 문제를 재구성해봐라. 이런 그래프의 간선은 무엇에 대응하는가?

총 홀수번 출현하는 숫자가 있으면, 답이 없다.

그렇지 않으면, 이분 그래프를 만들어보자. 왼쪽 부분은 배열(m개의 정점)을 의미하고 오른쪽 부분은 숫자를 의미한다.($\sum{n_i}$ 정점 까지) 각각의 배열의 정점은 중복을 세면서 배열에 포함된 모든 숫자에 연결되어 있다. 즉, 왼쪽 부분의 정점 a는 정점 b와 x번 연결되어 있다. x는 a번째 배열에서 b가 등장하는 횟수이다.

양 쪽에 있는 모든 정점은 짝수 차수라는 것을 기억해라. 왜냐하면 배열의 길이가 짝수이고 각각의 숫자의 출현 횟수도 짝수이기 때문이다. 그래서 우리는 이 그래프에서 방향 오릴러 회로를 찾을 수 잇다. a->b같은 간선들은 숫자 b를 L에 추가하고 a<-b같은 간선들은 b를 R에 추가하자.

이런 분할은 분명히 유효하다. 각각의 왼쪽에 있는 정점들에 대해 진입차수는 진출차수와 같고 그래서 각각의 배열이 반으로 나뉘고 각각의 오른쪽에 있는 정점들에 대해서도 같은 조건이 유지된다. 그래서 L과 R에 각각의 숫자가 등장하는 횟수가 같고 따라서 L=R이다.

아주 어려웠던 문제는 아닌 것 같은데 나는 이걸 그래프로 만들 생각은 아예 못 했고 오일러 회로도 안 짜 봐서 못 풀 문제였던 것 같다. 