# [Educational Codeforces Round 123 (Rated for Div. 2)](https://codeforces.com/contest/1644)

## C. Increase Subarray Sums

$mz_i$를 길이가 i인 것 중 최대값으로 놓는다. O(n^2)으로 구하기

k가 0~n일 때 각각 $mz_i$가 max(k,i)*x만큼 더해질 수 있다.

## D. Cross Coloring

구현을 제대로 하자.

어떻게 구현할 지 명확히 계획하자
무조건 빨리 짜려고 하지 말고 구현을 할 때 각각의 변수와 배열이 무엇을 의미하는지와 이 코드가 무슨 뜻인지를 생각하면서 짜자.

$x_i y_i$로 인해 칠해진 칸이 마지막에 하나라도 남아있으면 그 칸이 경우의 수에 영향을 미친다.
답은 색의 개수^마지막 상태에 영향을 미치는 수가 된다.

$x_i$ $y_i$가 영향을 미치지 않는 경우는 i인덱스 뒤에 $x_i$와 $y_i$가 등장하는 경우이다.

$x_i$행이 그 연산 이후에  등장하지 않아도 $y_i$열을 제외한 모든 열이 바뀐다면 $x_i$행이 등장하는 것으로 처리한다.

$y_i$열이 그 연산 이후에 등장하지 않아도 $x_i$행을 제외한 모든 행이 바뀐다면 $y_i$행이 등장하는 것으로 처리한다.

$y_i$열을 제외한 모든 열이 바뀌고 $x_i$행을 제외한 모든 행이 바뀌는 경우는 $(x_i,y_i)$ 1칸에 영향을 미치지 않는다.

따라서 이 경우는 마지막 상태에 영향을 미치는 연산으로 처리한다.

연산을 거꾸로 처리하면서 현재 연산이 이미 처리한 연산들과 겹치지 않는지 확인하면 된다.

이렇게 몇 가지 케이스에 대한 처리만 잘 해주면 된다.

## E. Expand the path

일단 R혹은 D만 등장하면 답은 무조건 n

R과 D가 둘 다 등장하는 경우를 보자.

R과 D를 확장하지 않고 1개만 썼을 때 $(R_E,C_E)$라고 하면

$(R_E,C_E)$~(N,N)은 경로를 확장했을 때 도달할 수 있는 곳들이다. ans=$(N-R_E+1)*(N-C_E+1)$로 놓자.

경로를 거꾸로 가며 확장할 수 있는 곳을 살펴본다.

현재 위치(R,C)를 $(R_E,C_E)$로 놓고 경로를 거꾸로 문자를 하나씩 보며 다음과 같은 연산을 한다.

'R'이 등장하면
C--, 
	D가 앞에 등장한다면 ans+=(N-R+1)-(이 문자 뒤의 D의 등장 횟수)
	그렇지 않다면 ans++

'D'가 등장하면 
	R이 앞에 등장한다면 R--, ans+=(N-C+1)-(이 문자 뒤의 R의 등장 횟수)
	그렇지 않다면 ans++

맨 앞의 R을 최대한 길게 확장시킨 경우와 R를 최대한 길게 확장시킨 경우 사이에 있는 칸들은 모두 이동할 수 있는 칸들이다.
이 칸이 나타내는 구역을 그려보고 위의 과정을 손으로 해보면 직관적으로 위의 과정이 맞다는 것을 알 수 있다.



D는 제대로 계획을 하지 않고 풀어서 페널티도 많았고 오래 걸렸다.

E는 여러 예제를 직관적인 그림으로 나타내고 케이스에 따라 시뮬레이션을 해보아서 비교적 빨리 풀었다.

명확하게 생각하고 계획하는 것이 중요